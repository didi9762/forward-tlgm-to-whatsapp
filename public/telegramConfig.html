<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="wa.css">
    <link rel="stylesheet" href="te.css">
    <title>Telegram Configuration</title>
</head>

<body>
    <!-- Fixed Alert Section -->
    <div id="channelAlert" style="display: none;"></div>
    
    <!-- Navigation Header -->
    <nav class="nav-header">
        <div class="nav-container">
            <a href="/" class="nav-logo">
                ü§ñ Telegram-WhatsApp Bot
            </a>
            <div class="nav-buttons">
                <a href="/" class="nav-btn">üè† Home</a>
                <a href="/whatsapp-config.html" class="nav-btn">üì± WhatsApp Config</a>
                <a href="/telegramConfig.html" class="nav-btn active">üí¨ Telegram Config</a>
                <a href="/twitterConfig.html" class="nav-btn">üê¶ Twitter Config</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="header telegram-header">
            <h1>üí¨ Telegram Configuration</h1>
            <p>Manage your Telegram connection and channel listening settings</p>
        </div>

        <div class="content">
            <!-- Connection Status Section -->
            <div class="section">
                <h2>üì° Connection Status</h2>
                <div id="connectionStatus" class="status-indicator status-loading">
                    <div class="status-dot"></div>
                    <span>Checking connection...</span>
                </div>

                <div class="auth-section" id="authSection" style="display: none;">
                    <label for="phoneNumber"><strong>Phone Number:</strong></label>
                    <input type="tel" id="phoneNumber" placeholder="+1234567890" class="form-input">
                    <button id="initializeBtn" class="btn btn-primary" onclick="initializeTelegram()">
                        <span id="initializeBtnText">üîë Initialize Telegram</span>
                    </button>
                </div>
                <!-- Add this section after the auth-section div -->
                <div class="code-section" id="codeSection" style="display: none;">
                    <label for="verificationCode"><strong>Verification Code:</strong></label>
                    <input type="text" id="verificationCode" placeholder="Enter the code from Telegram"
                        class="form-input" maxlength="5">
                    <button id="submitCodeBtn" class="btn btn-success" onclick="submitVerificationCode()">
                        <span id="submitCodeBtnText">‚úÖ Submit Code</span>
                    </button>
                </div>

                <div class="password-section" id="passwordSection" style="display: none;">
                    <label for="twoFAPassword"><strong>2FA Password:</strong></label>
                    <input type="password" id="twoFAPassword" placeholder="Enter your 2FA password" class="form-input">
                    <button id="submitPasswordBtn" class="btn btn-success" onclick="submit2FAPassword()">
                        <span id="submitPasswordBtnText">üîê Submit Password</span>
                    </button>
                </div>

                <button id="restartBtn" class="btn btn-danger" onclick="restartTelegram()" disabled>
                    <span id="restartBtnText">üîÑ Restart Telegram</span>
                </button>
                
                <button id="resetBtn" class="btn btn-reset-warning" onclick="resetTelegram()" disabled>
                    <span id="resetBtnText">‚ö†Ô∏è Reset Session</span>
                </button>
            </div>

            <!-- Client Info Section -->
            <div class="section">
                <h2>üë§ Client Information</h2>
                <div id="clientInfo" class="client-info">
                    <p><strong>Status:</strong> <span id="clientStatus">Not connected</span></p>
                    <p><strong>Name:</strong> <span id="clientName">-</span></p>
                    <p><strong>Username:</strong> <span id="clientUsername">-</span></p>
                    <p><strong>Phone:</strong> <span id="clientPhone">-</span></p>
                </div>
            </div>

            <!-- Channels/Groups Section -->
            <div class="section full-width">
                <h2>üì∫ Available Channels & Groups</h2>
                <div id="channelAlert" style="display: none;"></div>

                <div class="channel-controls">
                    <button id="loadChannelsBtn" class="btn" onclick="loadChannels()">
                        <span id="loadChannelsBtnText">üîÑ Load Channels</span>
                    </button>
                    <div class="channel-filter">
                        <input type="text" id="channelFilter" placeholder="Filter channels..." class="form-input"
                            oninput="filterChannels()">
                    </div>
                </div>

                <div id="channelsList" class="channels-list">
                    <div class="channels-placeholder">
                        üì∫ Click "Load Channels" to see your Telegram channels and groups
                    </div>
                </div>
            </div>

            <!-- Listening Channels Section -->
            <div class="section full-width">
                <h2>üéß Listening Channels</h2>
                <p>These channels are currently being monitored for messages</p>

                <div id="listeningChannels" class="listening-channels">
                    <div class="listening-placeholder">
                        üéß No channels are currently being monitored
                    </div>
                </div>

                <button id="saveListeningBtn" class="btn btn-success" onclick="saveListeningChannels()"
                    style="margin-top: 15px;">
                    üíæ Save Listening Configuration
                </button>
            </div>

            <!-- Message Forwarding Section -->
            <div class="section full-width">
                <h2>üîÑ Message Forwarding</h2>
                <div class="forwarding-info">
                    <p><strong>WhatsApp Target Group:</strong> <span id="whatsappTarget">Not configured</span></p>
                    <p><strong>Active Forwarding:</strong> <span id="forwardingStatus">‚ùå Inactive</span></p>
                </div>

                <div class="forwarding-controls">
                    <button id="setupForwardingBtn" class="btn btn-primary" onclick="setupForwarding()">
                        üöÄ Setup Forwarding
                    </button>
                    <button id="stopForwardingBtn" class="btn btn-danger" onclick="stopForwarding()" disabled>
                        ‚èπÔ∏è Stop Forwarding
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let statusInterval;
        let channels = [];
        let listeningChannels = [];
        let currentConfig = {};

        // Initialize page
        document.addEventListener('DOMContentLoaded', function () {
            checkConnectionStatus();
            loadConfiguration();
            loadListeningChannels();
            
            // Auto-load channels if Telegram is ready
            setTimeout(async () => {
                try {
                    const response = await fetch('/telegram/status');
                    const data = await response.json();
                    if (data.success && data.isReady) {
                        await loadChannels();
                    }
                } catch (error) {
                    console.log('Could not auto-load channels:', error);
                }
            }, 1000);
            
            startStatusUpdates();
        });

        // Check Telegram connection status
        async function checkConnectionStatus() {
            try {
                const response = await fetch('/telegram/status');
                const data = await response.json();

                const statusEl = document.getElementById('connectionStatus');
                const authSection = document.getElementById('authSection');
                const restartBtn = document.getElementById('restartBtn');
                const resetBtn = document.getElementById('resetBtn');

                if (data.success && data.isReady) {
                    statusEl.className = 'status-indicator status-connected';
                    statusEl.innerHTML = '<div class="status-dot"></div><span>‚úÖ Connected & Ready</span>';
                    authSection.style.display = 'none';
                    restartBtn.disabled = false;
                    resetBtn.disabled = false;
                    
                    // Fetch and display client information
                    try {
                        const infoResponse = await fetch('/telegram/info');
                        const infoData = await infoResponse.json();
                        if (infoData.success && infoData.clientInfo) {
                            updateClientInfo(infoData.clientInfo);
                        } else {
                            updateClientInfo(null);
                        }
                    } catch (infoError) {
                        console.error('Error fetching client info:', infoError);
                        updateClientInfo(null);
                    }
                } else {
                    statusEl.className = 'status-indicator status-disconnected';
                    statusEl.innerHTML = '<div class="status-dot"></div><span>‚ùå Not Connected</span>';
                    authSection.style.display = 'block';
                    restartBtn.disabled = false;
                    resetBtn.disabled = false;
                    
                    // Clear client info when not connected
                    updateClientInfo(null);
                    
                    // Check if we're in the middle of authentication
                    checkAuthStatus();
                }
            } catch (error) {
                console.error('Error checking status:', error);
                const statusEl = document.getElementById('connectionStatus');
                statusEl.className = 'status-indicator status-disconnected';
                statusEl.innerHTML = '<div class="status-dot"></div><span>‚ùå Connection Error</span>';
                
                // Clear client info on error
                updateClientInfo(null);
                
                // Check auth status even on error
                checkAuthStatus();
            }
        }

        // Update client info display
        function updateClientInfo(clientInfo) {
            if (clientInfo) {
                document.getElementById('clientStatus').textContent = 'Connected';
                document.getElementById('clientName').textContent = `${clientInfo.firstName || ''} ${clientInfo.lastName || ''}`.trim() || '-';
                document.getElementById('clientUsername').textContent = clientInfo.username ? `@${clientInfo.username}` : '-';
                document.getElementById('clientPhone').textContent = clientInfo.phone || '-';
            } else {
                document.getElementById('clientStatus').textContent = 'Not connected';
                document.getElementById('clientName').textContent = '-';
                document.getElementById('clientUsername').textContent = '-';
                document.getElementById('clientPhone').textContent = '-';
            }
        }

        // Initialize Telegram
        async function initializeTelegram() {
            const phoneNumber = document.getElementById('phoneNumber').value.trim();

            if (!phoneNumber) {
                showAlert('error', '‚ùå Please enter your phone number');
                return;
            }

            const initializeBtn = document.getElementById('initializeBtn');
            const initializeBtnText = document.getElementById('initializeBtnText');

            initializeBtn.disabled = true;
            initializeBtnText.innerHTML = '<div class="loading"></div> Initializing...';

            try {
                const response = await fetch('/telegram/initialize', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ phoneNumber })
                });

                const data = await response.json();

                if (data.success) {
                    showAlert('success', '‚úÖ Telegram initialization started!');
                    // Start checking auth status instead of immediate connection check
                    checkAuthStatus();
                } else {
                    showAlert('error', '‚ùå Failed to initialize Telegram: ' + data.error);
                }
            } catch (error) {
                console.error('Error initializing Telegram:', error);
                showAlert('error', '‚ùå Error initializing Telegram. Check console for details.');
                // Start checking auth status even on error to handle code prompts
                setTimeout(checkAuthStatus, 1000);
            } finally {
                initializeBtn.disabled = false;
                initializeBtnText.innerHTML = 'üîë Initialize Telegram';
            }
        }

        // Restart Telegram
        async function restartTelegram() {
            const restartBtn = document.getElementById('restartBtn');
            const restartBtnText = document.getElementById('restartBtnText');

            restartBtn.disabled = true;
            restartBtnText.innerHTML = '<div class="loading"></div> Restarting...';

            try {
                const response = await fetch('/telegram/restart', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    showAlert('success', '‚úÖ Telegram restarted successfully!');
                    setTimeout(() => {
                        checkConnectionStatus();
                        loadChannels();
                        loadListeningChannels();
                    }, 2000);
                } else {
                    showAlert('error', '‚ùå Failed to restart Telegram: ' + data.error);
                }
            } catch (error) {
                console.error('Error restarting Telegram:', error);
                showAlert('error', '‚ùå Error restarting Telegram');
            } finally {
                restartBtn.disabled = false;
                restartBtnText.innerHTML = 'üîÑ Restart Telegram';
            }
        }

        // Load channels
        async function loadChannels() {
            const loadChannelsBtn = document.getElementById('loadChannelsBtn');
            const loadChannelsBtnText = document.getElementById('loadChannelsBtnText');

            loadChannelsBtn.disabled = true;
            loadChannelsBtnText.innerHTML = '<div class="loading"></div> Loading...';

            try {
                const response = await fetch('/telegram/channels');
                const data = await response.json();

                const channelsList = document.getElementById('channelsList');

                if (data.success && data.channels) {
                    channels = data.channels;
                    console.log('channels', channels.slice(0, 10));
                    
                    renderChannels(channels);
                    renderListeningChannels();
                    showAlert('success', `‚úÖ Loaded ${data.channels.length} channels and groups`);
                } else {
                    channelsList.innerHTML = '<div class="channels-placeholder">‚ùå Failed to load channels</div>';
                    showAlert('error', '‚ùå Failed to load channels: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Error loading channels:', error);
                const channelsList = document.getElementById('channelsList');
                channelsList.innerHTML = '<div class="channels-placeholder">‚ùå Error loading channels</div>';
                showAlert('error', '‚ùå Error loading channels');
            } finally {
                loadChannelsBtn.disabled = false;
                loadChannelsBtnText.innerHTML = 'üîÑ Load Channels';
            }
        }

        // Render channels
        function renderChannels(channelsToRender) {
            const channelsList = document.getElementById('channelsList');

            if (channelsToRender.length === 0) {
                channelsList.innerHTML = '<div class="channels-placeholder">üì∫ No channels found</div>';
                return;
            }

            channelsList.innerHTML = channelsToRender.map(channel => `
                <div class="channel-item ${listeningChannels.includes(channel.id) ? 'listening' : ''}" data-channel-id="${channel.id}">
                    <div class="channel-info">
                        <div class="channel-title">
                            ${getChannelIcon(channel)} ${channel.title}
                        </div>
                        <div class="channel-details">
                            <span class="channel-type">${getChannelType(channel)}</span>
                            ${channel.participantsCount ? `<span class="channel-members">${channel.participantsCount} members</span>` : ''}
                        </div>
                    </div>
                    <button class="btn btn-sm ${listeningChannels.includes(channel.id) ? 'btn-danger' : 'btn-success'}" 
                            onclick="toggleChannelListening('${channel.id}')">
                        ${listeningChannels.includes(channel.id) ? 'üîá Stop Listening' : 'üéß Start Listening'}
                    </button>
                </div>
            `).join('');
        }

        // Get channel icon
        function getChannelIcon(channel) {
            if (channel.isChannel) return 'ÔøΩÔøΩ';
            if (channel.isMegagroup) return 'üí¨';
            if (channel.isGroup) return 'üë•';
            return 'üì±';
        }

        // Get channel type
        function getChannelType(channel) {
            if (channel.isChannel) return 'Channel';
            if (channel.isMegagroup) return 'Megagroup';
            if (channel.isGroup) return 'Group';
            return 'Chat';
        }

        // Filter channels
        function filterChannels() {
            const filter = document.getElementById('channelFilter').value.toLowerCase();
            const filteredChannels = channels.filter(channel =>
                channel.title.toLowerCase().includes(filter) ||
                (channel.username && channel.username.toLowerCase().includes(filter))
            );
            renderChannels(filteredChannels);
        }

        // Toggle channel listening
        async function toggleChannelListening(channelId) {
            const isListening = listeningChannels.includes(channelId);

            try {
                const response = await fetch('/telegram/update-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        telegramChannelIds: isListening 
                            ? listeningChannels.filter(id => id !== channelId)
                            : [...listeningChannels, channelId]
                    })
                });

                const data = await response.json();
                if (data.success) {
                    currentConfig = data.config;
                    listeningChannels = data.config.telegramChannelIds || [];
                    showAlert('success', isListening ? '‚úÖ Stopped listening to channel' : '‚úÖ Started listening to channel');
                    
                    // Re-render channels and listening list
                    const filter = document.getElementById('channelFilter').value.toLowerCase();
                    const filteredChannels = channels.filter(channel =>
                        channel.title.toLowerCase().includes(filter) ||
                        (channel.username && channel.username.toLowerCase().includes(filter))
                    );
                    renderChannels(filteredChannels);
                    renderListeningChannels();
                } else {
                    showAlert('error', '‚ùå Failed to update channels: ' + data.error);
                }
            } catch (error) {
                console.error('Error toggling channel listening:', error);
                showAlert('error', '‚ùå Error updating channels');
            }
        }

        // Load listening channels
        async function loadListeningChannels() {
            try {
                const response = await fetch('/config');
                const data = await response.json();

                if (data.success && data.config.telegramChannelIds) {
                    listeningChannels = data.config.telegramChannelIds || [];
                    renderListeningChannels();
                }
            } catch (error) {
                console.error('Error loading listening channels:', error);
            }
        }

        // Render listening channels
        function renderListeningChannels() {
            const listeningContainer = document.getElementById('listeningChannels');

            if (listeningChannels.length === 0) {
                listeningContainer.innerHTML = '<div class="listening-placeholder">üéß No channels are currently being monitored</div>';
                return;
            }

            const listeningChannelDetails = listeningChannels.map(channelId => {
                console.log('channelId', Math.abs(channelId));
                
                const channel = channels.find(c => c.id == Math.abs(channelId));
                if (channel) {
                    return channel;
                } else {
                    // For unknown channels, create a placeholder with the ID
                    return { 
                        id: channelId, 
                        title: `Unknown Channel (ID: ${channelId.substring(0, 10)}...)`, 
                        isChannel: true,
                        isUnknown: true // Flag to identify unknown channels
                    };
                }
            });

            listeningContainer.innerHTML = listeningChannelDetails.map(channel => `
                <div class="listening-channel-item ${channel.isUnknown ? 'unknown-channel' : ''}">
                    <div class="channel-info">
                        <div class="channel-title">
                            ${getChannelIcon(channel)} ${channel.title}
                            ${channel.isUnknown ? '<span class="unknown-badge">Unknown</span>' : ''}
                        </div>
                        <div class="channel-id">ID: ${channel.id}</div>
                    </div>
                    <button class="btn btn-sm btn-danger" onclick="toggleChannelListening('${channel.id}')">
                        üîá Remove
                    </button>
                </div>
            `).join('');

        }

        // Save listening channels (this is automatically done by the API)
        function saveListeningChannels() {
            showAlert('success', '‚úÖ Listening configuration is automatically saved');
        }

        // Load configuration
        async function loadConfiguration() {
            try {
                const response = await fetch('/config');
                const data = await response.json();

                if (data.success) {
                    currentConfig = data.config;
                    updateForwardingInfo();
                }
                
                // Also load forwarding status
                await loadForwardingStatus();
            } catch (error) {
                console.error('Error loading configuration:', error);
            }
        }

        // Load forwarding status
        async function loadForwardingStatus() {
            try {
                console.log('Loading forwarding status...');
                const response = await fetch('/telegram/forwarding-status');
                const data = await response.json();
                console.log('Forwarding status data:', data);

                if (data.success) {
                    const forwardingStatusEl = document.getElementById('forwardingStatus');
                    const setupBtn = document.getElementById('setupForwardingBtn');
                    const stopBtn = document.getElementById('stopForwardingBtn');

                    if (data.isActive) {
                        forwardingStatusEl.textContent = '‚úÖ Active';
                        setupBtn.style.display = 'none';
                        stopBtn.disabled = false;
                        stopBtn.style.display = 'inline-block';
                    } else {
                        forwardingStatusEl.textContent = '‚ùå Inactive';
                        setupBtn.style.display = 'inline-block';
                        stopBtn.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error loading forwarding status:', error);
            }
        }

        // Update forwarding info
        function updateForwardingInfo() {
            const whatsappTarget = document.getElementById('whatsappTarget');
            whatsappTarget.textContent = currentConfig.whatsappGroupId || 'Not configured';
        }

        // Setup forwarding
        async function setupForwarding() {
            if (!currentConfig.whatsappGroupId) {
                showAlert('error', '‚ùå Please configure WhatsApp target group first');
                return;
            }

            if (!currentConfig.telegramChannelIds || currentConfig.telegramChannelIds.length === 0) {
                showAlert('error', '‚ùå Please select channels to listen to first');
                return;
            }

            const setupBtn = document.getElementById('setupForwardingBtn');
            const stopBtn = document.getElementById('stopForwardingBtn');
            const forwardingStatusEl = document.getElementById('forwardingStatus');

            setupBtn.disabled = true;
            setupBtn.innerHTML = '<div class="loading"></div> Setting up...';
            forwardingStatusEl.textContent = 'üîÑ Setting up...';

            try {
                // Update config to active and start forwarding
                const response = await fetch('/telegram/update-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        isActive: true
                    })
                });

                const data = await response.json();

                if (data.success) {
                    currentConfig = data.config;
                    
                    // Try to start forwarding
                    const startResponse = await fetch('/telegram/start-forwarding', {
                        method: 'POST'
                    });

                    const startData = await startResponse.json();

                    if (startData.success) {
                        forwardingStatusEl.textContent = '‚úÖ Active';
                        setupBtn.style.display = 'none';
                        stopBtn.disabled = false;
                        stopBtn.style.display = 'inline-block';
                        showAlert('success', '‚úÖ Message forwarding setup successfully!');
                    } else {
                        throw new Error('Failed to start forwarding: ' + startData.error);
                    }
                } else {
                    throw new Error('Failed to update config: ' + data.error);
                }
            } catch (error) {
                console.error('Error setting up forwarding:', error);
                forwardingStatusEl.textContent = '‚ùå Setup Failed';
                showAlert('error', '‚ùå Error setting up forwarding: ' + error.message);
            } finally {
                setupBtn.disabled = false;
                setupBtn.innerHTML = 'üöÄ Setup Forwarding';
            }
        }

        // Stop forwarding
        async function stopForwarding() {
            const setupBtn = document.getElementById('setupForwardingBtn');
            const stopBtn = document.getElementById('stopForwardingBtn');

            stopBtn.disabled = true;
            stopBtn.innerHTML = '<div class="loading"></div> Stopping...';

            try {
                // Set config to inactive
                const configResponse = await fetch('/telegram/update-config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        isActive: false
                    })
                });

                const configData = await configResponse.json();
                if (configData.success) {
                    currentConfig = configData.config;
                }

                // Stop forwarding
                const response = await fetch('/telegram/stop-forwarding', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    document.getElementById('forwardingStatus').textContent = '‚ùå Inactive';
                    setupBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                    showAlert('success', '‚úÖ Message forwarding stopped');
                } else {
                    showAlert('error', '‚ùå Failed to stop forwarding: ' + data.error);
                }
            } catch (error) {
                console.error('Error stopping forwarding:', error);
                showAlert('error', '‚ùå Error stopping forwarding');
            } finally {
                stopBtn.disabled = false;
                stopBtn.innerHTML = '‚èπÔ∏è Stop Forwarding';
            }
        }

        // Start status updates
        function startStatusUpdates() {
            statusInterval = setInterval(checkConnectionStatus, 10000);
        }

        // Show alert
        function showAlert(type, message) {
            const alertEl = document.getElementById('channelAlert');
            const body = document.body;
            
            alertEl.className = `alert alert-${type}`;
            alertEl.textContent = message;
            alertEl.style.display = 'block';
            
            // Add show class and body padding
            setTimeout(() => {
                alertEl.classList.add('show');
                body.classList.add('alert-shown');
            }, 10);

            // Hide after 5 seconds
            setTimeout(() => {
                alertEl.classList.remove('show');
                body.classList.remove('alert-shown');
                
                // Hide completely after animation
                setTimeout(() => {
                    alertEl.style.display = 'none';
                }, 300);
            }, 5000);
        }

        // Submit verification code
        async function submitVerificationCode() {
            const code = document.getElementById('verificationCode').value.trim();

            if (!code) {
                showAlert('error', '‚ùå Please enter the verification code');
                return;
            }

            const submitCodeBtn = document.getElementById('submitCodeBtn');
            const submitCodeBtnText = document.getElementById('submitCodeBtnText');

            submitCodeBtn.disabled = true;
            submitCodeBtnText.innerHTML = '<div class="loading"></div> Submitting...';

            try {
                const response = await fetch('/telegram/submit-code', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ code })
                });

                const data = await response.json();

                if (data.success) {
                    showAlert('success', '‚úÖ Code submitted successfully!');
                    document.getElementById('codeSection').style.display = 'none';
                    // Start checking auth status
                    checkAuthStatus();
                } else {
                    showAlert('error', '‚ùå Failed to submit code: ' + data.error);
                }
            } catch (error) {
                console.error('Error submitting code:', error);
                showAlert('error', '‚ùå Error submitting code');
            } finally {
                submitCodeBtn.disabled = false;
                submitCodeBtnText.innerHTML = '‚úÖ Submit Code';
            }
        }

        // Submit 2FA password
        async function submit2FAPassword() {
            const password = document.getElementById('twoFAPassword').value.trim();

            if (!password) {
                showAlert('error', '‚ùå Please enter your 2FA password');
                return;
            }

            const submitPasswordBtn = document.getElementById('submitPasswordBtn');
            const submitPasswordBtnText = document.getElementById('submitPasswordBtnText');

            submitPasswordBtn.disabled = true;
            submitPasswordBtnText.innerHTML = '<div class="loading"></div> Submitting...';

            try {
                const response = await fetch('/telegram/submit-password', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ password })
                });

                const data = await response.json();

                if (data.success) {
                    showAlert('success', '‚úÖ Password submitted successfully!');
                    document.getElementById('passwordSection').style.display = 'none';
                    // Start checking auth status
                    checkAuthStatus();
                } else {
                    showAlert('error', '‚ùå Failed to submit password: ' + data.error);
                }
            } catch (error) {
                console.error('Error submitting password:', error);
                showAlert('error', '‚ùå Error submitting password');
            } finally {
                submitPasswordBtn.disabled = false;
                submitPasswordBtnText.innerHTML = 'üîê Submit Password';
            }
        }

        // Check authentication status
        async function checkAuthStatus() {
            try {
                const response = await fetch(`/telegram/auth-status?_t=${Date.now()}`);
                const data = await response.json();

                if (data.success) {
                    if (data.isWaitingForPhoneCode) {
                        document.getElementById('codeSection').style.display = 'block';
                        document.getElementById('passwordSection').style.display = 'none';
                        showAlert('info', 'üì± Please check your Telegram app for the verification code');
                    } else if (data.isWaitingForPassword) {
                        document.getElementById('codeSection').style.display = 'none';
                        document.getElementById('passwordSection').style.display = 'block';
                        showAlert('info', 'üîê Please enter your 2FA password');
                    } else if (data.isReady) {
                        document.getElementById('codeSection').style.display = 'none';
                        document.getElementById('passwordSection').style.display = 'none';
                        document.getElementById('authSection').style.display = 'none';
                        checkConnectionStatus();
                    } else if (data.isAuthenticating) {
                        // Still authenticating, check again in 2 seconds
                        setTimeout(checkAuthStatus, 2000);
                    }
                }
            } catch (error) {
                console.error('Error checking auth status:', error);
            }
        }

        // Reset Telegram (delete session)
        async function resetTelegram() {
            if (!confirm('‚ö†Ô∏è Are you sure you want to reset Telegram? This will delete your session and you will need to authenticate again.')) {
                return;
            }

            const resetBtn = document.getElementById('resetBtn');
            const resetBtnText = document.getElementById('resetBtnText');

            resetBtn.disabled = true;
            resetBtnText.innerHTML = '<div class="loading"></div> Resetting...';

            try {
                const response = await fetch('/telegram/reset', {
                    method: 'POST'
                });

                const data = await response.json();

                if (data.success) {
                    showAlert('success', '‚úÖ Telegram session reset successfully! Please initialize again.');
                    
                    // Clear UI state
                    listeningChannels = [];
                    channels = [];
                    
                    // Reset UI elements
                    document.getElementById('channelsList').innerHTML = '<div class="channels-placeholder">üì∫ Click "Load Channels" to see your Telegram channels and groups</div>';
                    document.getElementById('listeningChannels').innerHTML = '<div class="listening-placeholder">üéß No channels are currently being monitored</div>';
                    document.getElementById('forwardingStatus').textContent = '‚ùå Inactive';
                    document.getElementById('setupForwardingBtn').style.display = 'inline-block';
                    document.getElementById('stopForwardingBtn').style.display = 'none';
                    
                    // Show auth section
                    document.getElementById('authSection').style.display = 'block';
                    document.getElementById('codeSection').style.display = 'none';
                    document.getElementById('passwordSection').style.display = 'none';
                    
                    // Update connection status
                    setTimeout(() => {
                        checkConnectionStatus();
                    }, 1000);
                } else {
                    showAlert('error', '‚ùå Failed to reset Telegram: ' + data.error);
                }
            } catch (error) {
                console.error('Error resetting Telegram:', error);
                showAlert('error', '‚ùå Error resetting Telegram');
            } finally {
                resetBtn.disabled = false;
                resetBtnText.innerHTML = '‚ö†Ô∏è Reset Session';
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function () {
            if (statusInterval) {
                clearInterval(statusInterval);
            }
        });
    </script>
</body>

</html>